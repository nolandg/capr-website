"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const crypto_1 = require("crypto");
const net_1 = require("net");
const path_1 = require("path");
const fs_1 = require("fs");
const middleware_1 = require("./middleware");
const LineWrapper = require('stream-line-wrapper');
class Engine {
    constructor(config) {
        this.started = false;
        this.killed = false;
        this.middlewareParams = new middleware_1.MiddlewareParams();
        this.middlewareParams.endpoint = config.endpoint || '/graphql';
        this.middlewareParams.psk = crypto_1.randomBytes(48).toString("hex");
        this.middlewareParams.dumpTraffic = config.dumpTraffic || false;
        if (config.graphqlPort) {
            this.graphqlPort = config.graphqlPort;
        }
        else {
            const port = process.env.PORT;
            if (port) {
                this.graphqlPort = parseInt(port, 10);
            }
            else {
                throw new Error('process.env.PORT is not set!');
            }
        }
        this.config = config.engineConfig;
        switch (process.platform) {
            case 'darwin': {
                this.binary = 'apollo-engine-binary-darwin/engineproxy_darwin_amd64';
                break;
            }
            case 'linux': {
                this.binary = 'apollo-engine-binary-linux/engineproxy_linux_amd64';
                break;
            }
            case 'win32': {
                this.binary = 'apollo-engine-binary-windows/engineproxy_windows_amd64.exe';
                break;
            }
            default: {
                throw new Error('Unsupported platform');
            }
        }
    }
    start() {
        if (this.started) {
            throw new Error('Only call start() on an engine object once');
        }
        this.started = true;
        let config = this.config;
        const endpoint = this.middlewareParams.endpoint;
        const graphqlPort = this.graphqlPort;
        if (typeof config === 'string') {
            config = JSON.parse(fs_1.readFileSync(config, 'utf8'));
        }
        // Allocate a random port for the proxy:
        const srv = net_1.createServer();
        return new Promise(resultPort => {
            srv.on('listening', () => {
                const port = srv.address().port;
                srv.close();
                this.middlewareParams.uri = 'http://127.0.0.1:' + port;
                // Customize configuration:
                const childConfig = Object.assign({}, config);
                // Inject frontend, that we will route
                let frontend = {
                    host: '127.0.0.1',
                    endpoint,
                    port
                };
                if (typeof childConfig.frontends === 'undefined') {
                    childConfig.frontends = [frontend];
                }
                else {
                    childConfig.frontends.push(frontend);
                }
                if (typeof childConfig.origins === 'undefined') {
                    childConfig.origins = [{
                            http: {
                                url: 'http://127.0.0.1:' + graphqlPort + endpoint,
                                headerSecret: this.middlewareParams.psk
                            }
                        }];
                }
                else {
                    // Extend any existing HTTP origins with the chosen PSK:
                    childConfig.origins.forEach(origin => {
                        if (typeof origin.http === 'object') {
                            origin.http.headerSecret = this.middlewareParams.psk;
                        }
                    });
                }
                let binaryPath = path_1.resolve(__dirname, '../node_modules', this.binary);
                if (!fs_1.existsSync(binaryPath)) {
                    binaryPath = path_1.resolve(__dirname, '../../../node_modules', this.binary);
                }
                const childOptions = {
                    'env': Object.assign({ 'ENGINE_CONFIG': JSON.stringify(childConfig) }, process.env),
                    'maxBuffer': 5 * 1024 * 1024
                };
                let child = child_process_1.spawn(binaryPath, ['-config=env', '-restart=true'], childOptions);
                child.stdout.pipe(this.engineLineWrapper()).pipe(process.stdout);
                child.stderr.pipe(this.engineLineWrapper()).pipe(process.stderr);
                child.on('exit', (code, signal) => {
                    if (this.killed) {
                        // It's not an error if we think it's our fault.
                        return;
                    }
                    if (child != null) {
                        if (code != null) {
                            throw new Error(`Engine crashed unexpectedly with code: ${code}`);
                        }
                        if (signal != null) {
                            throw new Error(`Engine was killed unexpectedly by signal: ${signal}`);
                        }
                        throw new Error("Engine crashed unexpectedly");
                    }
                });
                this.child = child;
                resultPort(port);
            }).listen(0);
        });
    }
    microMiddleware() {
        return middleware_1.makeMicroMiddleware(this.middlewareParams);
    }
    expressMiddleware() {
        return middleware_1.makeExpressMiddleware(this.middlewareParams);
    }
    connectMiddleware() {
        return middleware_1.makeConnectMiddleware(this.middlewareParams);
    }
    koaMiddleware() {
        return middleware_1.makeKoaMiddleware(this.middlewareParams);
    }
    instrumentHapiServer(server) {
        middleware_1.instrumentHapi(server, this.middlewareParams);
    }
    stop() {
        if (this.child == null) {
            throw new Error('No engine instance running...');
        }
        const childRef = this.child;
        this.child = null;
        this.killed = true;
        childRef.kill();
    }
    engineLineWrapper() {
        return new LineWrapper({ prefix: 'EngineProxy ==> ' });
    }
}
exports.Engine = Engine;
//# sourceMappingURL=index.js.map