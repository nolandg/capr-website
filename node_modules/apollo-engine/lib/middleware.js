"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const request = require("request");
const url_1 = require("url");
class MiddlewareParams {
}
exports.MiddlewareParams = MiddlewareParams;
function makeMicroMiddleware(params) {
    return function (fn) {
        return function (req, res) {
            const { pathname } = url_1.parse(req.url || '');
            if (!params.uri || pathname !== params.endpoint)
                return fn(req, res);
            else if (req.method !== 'GET' && req.method !== 'POST')
                return fn(req, res);
            else if (req.headers['x-engine-from'] === params.psk)
                return fn(req, res);
            else
                proxyRequest(params, req, res);
        };
    };
}
exports.makeMicroMiddleware = makeMicroMiddleware;
function makeExpressMiddleware(params) {
    const endpointRegex = new RegExp(`^${params.endpoint}(\\?|$)`);
    return function (req, res, next) {
        if (!params.uri || !endpointRegex.test(req.originalUrl))
            next();
        else if (req.method !== 'GET' && req.method !== 'POST')
            next();
        else if (req.headers['x-engine-from'] === params.psk)
            next();
        else {
            req.url = req.originalUrl;
            proxyRequest(params, req, res);
        }
    };
}
exports.makeExpressMiddleware = makeExpressMiddleware;
function makeConnectMiddleware(params) {
    const endpointRegex = new RegExp(`^${params.endpoint}(\\?|$)`);
    return function (req, res, next) {
        if (!params.uri || !endpointRegex.test(req.originalUrl))
            next();
        else if (req.method !== 'GET' && req.method !== 'POST')
            next();
        else if (req.headers['x-engine-from'] === params.psk)
            next();
        else {
            req.url = req.originalUrl;
            proxyRequest(params, req, res);
        }
    };
}
exports.makeConnectMiddleware = makeConnectMiddleware;
function makeKoaMiddleware(params) {
    return function (ctx, next) {
        if (!params.uri || ctx.path !== params.endpoint)
            return next();
        else if (ctx.req.headers['x-engine-from'] === params.psk)
            return next();
        else if (ctx.req.method !== 'GET' && ctx.req.method !== 'POST')
            return next();
        else
            return new Promise((resolve) => {
                ctx.req.pipe(request(params.uri + ctx.originalUrl, (error, response, body) => {
                    if (response.statusCode)
                        ctx.response.status = response.statusCode;
                    ctx.response.set(JSON.parse(JSON.stringify(response.headers)));
                    ctx.response.body = body;
                    resolve();
                }));
            });
    };
}
exports.makeKoaMiddleware = makeKoaMiddleware;
function instrumentHapi(server, params) {
    server.ext('onRequest', (req, reply) => {
        if (!params.uri)
            return reply.continue();
        const path = req.url.pathname;
        if (!path || path !== params.endpoint)
            return reply.continue();
        else if (req.method !== 'get' && req.method !== 'post')
            return reply.continue();
        else if (req.headers['x-engine-from'] === params.psk)
            return reply.continue();
        else
            proxyRequest(params, req.raw.req, req.raw.res);
    });
}
exports.instrumentHapi = instrumentHapi;
function proxyRequest(params, req, res) {
    if (params.dumpTraffic) {
        req.pipe(process.stdout);
    }
    let proxyRes = req.pipe(request(params.uri + req.url));
    if (params.dumpTraffic) {
        proxyRes.pipe(process.stdout);
    }
    proxyRes.pipe(res);
}
//# sourceMappingURL=middleware.js.map