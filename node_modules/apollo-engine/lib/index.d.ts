export declare type LogLevels = 'debug' | 'info' | 'warn' | 'error' | 'fatal';
export interface AccessLogConfig {
    destination: string;
    requestHeaders?: string[];
    responseHeaders?: string[];
}
export interface EngineConfig {
    apiKey: string;
    origins?: {
        http: {
            url: string;
            headerSecret: string;
        };
        requestTimeout?: string;
        maxConcurrentRequests?: number;
    }[];
    frontends?: {
        host: string;
        endpoint: string;
        port: number;
    }[];
    stores?: {
        name: string;
        memcache?: {
            url: string[];
            timeout?: string;
            keyPrefix?: string;
        };
        inMemory?: {
            cacheSize?: number;
        };
    }[];
    sessionAuth?: {
        header?: string;
        cookie?: string;
        tokenAuthUrl?: string;
        store?: string;
    };
    logging?: {
        level?: LogLevels;
        request?: AccessLogConfig;
        query?: AccessLogConfig;
    };
    reporting?: {
        endpointUrl?: string;
        maxAttempts?: number;
        retryMinimum?: string;
        retryMaximum?: string;
        debugReports?: boolean;
        noTraceVariables?: boolean;
        privateHeaders?: string[];
    };
    queryCache?: {
        publicFullQueryStore?: string;
        privateFullQueryStore?: string;
    };
}
export interface SideloadConfig {
    engineConfig: string | EngineConfig;
    endpoint?: string;
    graphqlPort?: number;
    dumpTraffic?: boolean;
}
export declare class Engine {
    private child;
    private graphqlPort;
    private binary;
    private config;
    private middlewareParams;
    private started;
    private killed;
    constructor(config: SideloadConfig);
    start(): Promise<number>;
    microMiddleware(): (fn: Function) => void;
    expressMiddleware(): (req: any, res: any, next: any) => void;
    connectMiddleware(): (req: any, res: any, next: any) => void;
    koaMiddleware(): (ctx: any, next: any) => void;
    instrumentHapiServer(server: any): void;
    stop(): void;
    private engineLineWrapper();
}
